[
  {
    "objectID": "mp01.html",
    "href": "mp01.html",
    "title": "Transit Data Analysis",
    "section": "",
    "text": "This analysis will examine the fiscal characteristics of major U.S. public transit systems using publicly available data. For more details on the problem description, please refer to: Mini-Project #01. The primary objective is to answer key questions related to transit agencies, focusing on areas such as farebox recovery performance, ridership trends, and operating expenses. The analysis will involve tasks such as renaming columns, recoding modes, and addressing instructor-specified questions using various transit data sources."
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Transit Data Analysis",
    "section": "",
    "text": "Install Required Packages\n\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\nLoading required package: tidyverse\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nif(!require(\"lubridate\")) install.packages(\"lubridate\")\nif(!require(\"DT\")) install.packages(\"DT\")\n\nLoading required package: DT\n\n\n\n\nLoad the packages\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(readr)\nlibrary(lubridate)\nlibrary(DT)\n\n\nlibrary(tidyverse)\nif(!file.exists(\"2022_fare_revenue.xlsx\")){\n    # This should work _in theory_ but in practice it's still a bit finicky\n    # If it doesn't work for you, download this file 'by hand' in your\n    # browser and save it as \"2022_fare_revenue.xlsx\" in your project\n    # directory.\n    download.file(\"http://www.transit.dot.gov/sites/fta.dot.gov/files/2024-04/2022%20Fare%20Revenue.xlsx\", \n                  destfile=\"2022_fare_revenue.xlsx\", \n                  quiet=FALSE, \n                  method=\"wget\")\n}\nFARES &lt;- readxl::read_xlsx(\"2022_fare_revenue.xlsx\") |&gt;\n    select(-`State/Parent NTD ID`, \n           -`Reporter Type`,\n           -`Reporting Module`,\n           -`TOS`,\n           -`Passenger Paid Fares`,\n           -`Organization Paid Fares`) |&gt;\n    filter(`Expense Type` == \"Funds Earned During Period\") |&gt;\n    select(-`Expense Type`) |&gt;\n    group_by(`NTD ID`,       # Sum over different `TOS` for the same `Mode`\n             `Agency Name`,  # These are direct operated and sub-contracted \n             `Mode`) |&gt;      # of the same transit modality\n                             # Not a big effect in most munis (significant DO\n                             # tends to get rid of sub-contractors), but we'll sum\n                             # to unify different passenger experiences\n    summarize(`Total Fares` = sum(`Total Fares`)) |&gt;\n    ungroup()\n\n`summarise()` has grouped output by 'NTD ID', 'Agency Name'. You can override\nusing the `.groups` argument.\n\n\n\n# Next, expenses\nif(!file.exists(\"2022_expenses.csv\")){\n    # This should work _in theory_ but in practice it's still a bit finicky\n    # If it doesn't work for you, download this file 'by hand' in your\n    # browser and save it as \"2022_expenses.csv\" in your project\n    # directory.\n    download.file(\"https://data.transportation.gov/api/views/dkxx-zjd6/rows.csv?date=20231102&accessType=DOWNLOAD&bom=true&format=true\", \n                  destfile=\"2022_expenses.csv\", \n                  quiet=FALSE, \n                  method=\"wget\")\n}\nEXPENSES &lt;- readr::read_csv(\"2022_expenses.csv\") |&gt;\n    select(`NTD ID`, \n           `Agency`,\n           `Total`, \n           `Mode`) |&gt;\n    mutate(`NTD ID` = as.integer(`NTD ID`)) |&gt;\n    rename(Expenses = Total) |&gt;\n    group_by(`NTD ID`, `Mode`) |&gt;\n    summarize(Expenses = sum(Expenses)) |&gt;\n    ungroup()\n\nRows: 3744 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (10): Agency, City, State, NTD ID, Organization Type, Reporter Type, UZA...\ndbl  (2): Report Year, UACE Code\nnum (10): Primary UZA Population, Agency VOMS, Mode VOMS, Vehicle Operations...\nlgl  (7): Vehicle Operations Questionable, Vehicle Maintenance Questionable,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n`summarise()` has grouped output by 'NTD ID'. You can override using the `.groups` argument.\n\nFINANCIALS &lt;- inner_join(FARES, EXPENSES, join_by(`NTD ID`, `Mode`))\n\n\n# Monthly Transit Numbers\nlibrary(tidyverse)\nif(!file.exists(\"ridership.xlsx\")){\n    # This should work _in theory_ but in practice it's still a bit finicky\n    # If it doesn't work for you, download this file 'by hand' in your\n    # browser and save it as \"ridership.xlsx\" in your project\n    # directory.\n    download.file(\"https://www.transit.dot.gov/sites/fta.dot.gov/files/2024-09/July%202024%20Complete%20Monthly%20Ridership%20%28with%20adjustments%20and%20estimates%29_240903.xlsx\", \n                  destfile=\"ridership.xlsx\", \n                  quiet=FALSE, \n                  method=\"wget\")\n}\nTRIPS &lt;- readxl::read_xlsx(\"ridership.xlsx\", sheet=\"UPT\") |&gt;\n            filter(`Mode/Type of Service Status` == \"Active\") |&gt;\n            select(-`Legacy NTD ID`, \n                   -`Reporter Type`, \n                   -`Mode/Type of Service Status`, \n                   -`UACE CD`, \n                   -`TOS`) |&gt;\n            pivot_longer(-c(`NTD ID`:`3 Mode`), \n                            names_to=\"month\", \n                            values_to=\"UPT\") |&gt;\n            drop_na() |&gt;\n            mutate(month=my(month)) # Parse _m_onth _y_ear date specs\nMILES &lt;- readxl::read_xlsx(\"ridership.xlsx\", sheet=\"VRM\") |&gt;\n            filter(`Mode/Type of Service Status` == \"Active\") |&gt;\n            select(-`Legacy NTD ID`, \n                   -`Reporter Type`, \n                   -`Mode/Type of Service Status`, \n                   -`UACE CD`, \n                   -`TOS`) |&gt;\n            pivot_longer(-c(`NTD ID`:`3 Mode`), \n                            names_to=\"month\", \n                            values_to=\"VRM\") |&gt;\n            drop_na() |&gt;\n            group_by(`NTD ID`, `Agency`, `UZA Name`, \n                     `Mode`, `3 Mode`, month) |&gt;\n            summarize(VRM = sum(VRM)) |&gt;\n            ungroup() |&gt;\n            mutate(month=my(month)) # Parse _m_onth _y_ear date specs\n\n`summarise()` has grouped output by 'NTD ID', 'Agency', 'UZA Name', 'Mode', '3\nMode'. You can override using the `.groups` argument.\n\nUSAGE &lt;- inner_join(TRIPS, MILES) |&gt;\n    mutate(`NTD ID` = as.integer(`NTD ID`))\n\nJoining with `by = join_by(`NTD ID`, Agency, `UZA Name`, Mode, `3 Mode`,\nmonth)`"
  },
  {
    "objectID": "mp01.html#library-setup",
    "href": "mp01.html#library-setup",
    "title": "Transit Data Analysis",
    "section": "Library Setup",
    "text": "Library Setup\n\nInstall Required Packages\nWe will be analyzing various data from various sources. Following libraries are needed for this analysis. First check if the library is already installed and then install if not installed.\n\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif (!require(\"lubridate\")) install.packages(\"lubridate\")\nif (!require(\"DT\")) install.packages(\"DT\")\n\n\n\nLoad the packages\nOnce the packages are installed, those will be loaded to the workspace so that they can be used later.\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(readr)\nlibrary(lubridate)\nlibrary(DT)"
  },
  {
    "objectID": "mp01.html#load-data",
    "href": "mp01.html#load-data",
    "title": "Transit Data Analysis",
    "section": "Load Data",
    "text": "Load Data\nSince we have now setup libraries, we will now download the data to our project so that we can use later fo our analysis. You might get an error when trying to download the file programmatically. If the error persists, download the files manually and rename those and copy them to project folder.\n\nLoading Fare Revenue Data\nWe will first Load Fare revenue data from 2022 Fare Revenue table. This table Contains data on revenues a transit agency earns from carrying passengers, organized by mode and type of service. Reported as funds earned, funds expended on operations, and funds expended on capital.\n\n# Let's start with Fare Revenue\nlibrary(tidyverse)\nif (!file.exists(\"2022_fare_revenue.xlsx\")) {\n  # This should work _in theory_ but in practice it's still a bit finicky\n  # If it doesn't work for you, download this file 'by hand' in your\n  # browser and save it as \"2022_fare_revenue.xlsx\" in your project\n  # directory.\n  download.file(\"http://www.transit.dot.gov/sites/fta.dot.gov/files/2024-04/2022%20Fare%20Revenue.xlsx\",\n    destfile = \"2022_fare_revenue.xlsx\",\n    quiet = FALSE,\n    method = \"wget\"\n  )\n}\nFARES &lt;- readxl::read_xlsx(\"2022_fare_revenue.xlsx\") |&gt;\n  select(\n    -`State/Parent NTD ID`,\n    -`Reporter Type`,\n    -`Reporting Module`,\n    -`TOS`,\n    -`Passenger Paid Fares`,\n    -`Organization Paid Fares`\n  ) |&gt;\n  filter(`Expense Type` == \"Funds Earned During Period\") |&gt;\n  select(-`Expense Type`) |&gt;\n  group_by(\n    `NTD ID`, # Sum over different `TOS` for the same `Mode`\n    `Agency Name`, # These are direct operated and sub-contracted\n    `Mode`\n  ) |&gt; # of the same transit modality\n  # Not a big effect in most munis (significant DO\n  # tends to get rid of sub-contractors), but we'll sum\n  # to unify different passenger experiences\n  summarize(`Total Fares` = sum(`Total Fares`)) |&gt;\n  ungroup()\n\n\n\nNext load Expenses\nThe 2022 Annual dataset containing data on expenses applied to operate public transportation services for each agency, by mode, and type of service operated. Divides expenses among NTD expense functions and object classes.\n\n# Next, expenses\nif (!file.exists(\"2022_expenses.csv\")) {\n  # This should work _in theory_ but in practice it's still a bit finicky\n  # If it doesn't work for you, download this file 'by hand' in your\n  # browser and save it as \"2022_expenses.csv\" in your project\n  # directory.\n  download.file(\"https://data.transportation.gov/api/views/dkxx-zjd6/rows.csv?date=20231102&accessType=DOWNLOAD&bom=true&format=true\",\n    destfile = \"2022_expenses.csv\",\n    quiet = FALSE,\n    method = \"wget\"\n  )\n}\nEXPENSES &lt;- readr::read_csv(\"2022_expenses.csv\") |&gt;\n  select(\n    `NTD ID`,\n    `Agency`,\n    `Total`,\n    `Mode`\n  ) |&gt;\n  mutate(`NTD ID` = as.integer(`NTD ID`)) |&gt;\n  rename(Expenses = Total) |&gt;\n  group_by(`NTD ID`, `Mode`) |&gt;\n  summarize(Expenses = sum(Expenses)) |&gt;\n  ungroup()"
  },
  {
    "objectID": "mp01.html#tasks",
    "href": "mp01.html#tasks",
    "title": "Transit Data Analysis",
    "section": "Tasks",
    "text": "Tasks\nNow, we will complete the tasks mentioned in this page\n\n\n\n\n\n\nTask 1 - Creating Syntatic Names\n\n\n\nRename a column: UZA Name to metro_area.\n\nUSAGE &lt;- USAGE |&gt; rename(metro_area = \"UZA Name\")\n\nWe will also rename few other columns to make them more readable\n\nUSAGE &lt;- USAGE |&gt;\n  rename(Passenger_Trips = UPT, Vehicle_Miles = VRM)\n\n\n\n\n\n\n\n\n\nTask 2: Recoding the Mode column\n\n\n\nFind Unique Modes and Print.\n\nunique_modes &lt;- USAGE |&gt;\n  distinct(Mode)\n\nprint(unique_modes)\n\n# A tibble: 18 × 1\n   Mode \n   &lt;chr&gt;\n 1 DR   \n 2 FB   \n 3 MB   \n 4 SR   \n 5 TB   \n 6 VP   \n 7 CB   \n 8 RB   \n 9 LR   \n10 YR   \n11 MG   \n12 CR   \n13 AR   \n14 TR   \n15 HR   \n16 IP   \n17 PB   \n18 CC   \n\n\nNow we will get the meaning of these symbols from NDT website. Once we have the meaning for each Acronyms, we will replace using case-when.\n\nUSAGE &lt;- USAGE |&gt;\n  mutate(Mode = case_when(\n    Mode == \"DR\" ~ \"Demand Response\",\n    Mode == \"FB\" ~ \"Ferryboat\",\n    Mode == \"MB\" ~ \"Motorbus\",\n    Mode == \"SR\" ~ \"Streetcar Rail\",\n    Mode == \"TB\" ~ \"Trolleybus\",\n    Mode == \"VP\" ~ \"Vanpool\",\n    Mode == \"CB\" ~ \"Commuter Bus\",\n    Mode == \"RB\" ~ \"Bus Rapid Transit\",\n    Mode == \"LR\" ~ \"Light Rail\",\n    Mode == \"YR\" ~ \"Hybrid Rail\",\n    Mode == \"MG\" ~ \"Monorail/Automated Guideway\",\n    Mode == \"CR\" ~ \"Commuter Rail\",\n    Mode == \"AR\" ~ \"Alaska Railroad\",\n    Mode == \"TR\" ~ \"Aerial Tramway\",\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"IP\" ~ \"Inclined Plane\",\n    Mode == \"PB\" ~ \"Publico\",\n    Mode == \"CC\" ~ \"Cable Car\",\n    TRUE ~ \"Unknown\"\n  ))\n\n\n\n\n\n\n\n\n\nTask 3: Answering Instructor Specified Questions with dplyr\n\n\n\n\n1. What transit agency had the most total VRM in this sample?\n\nUSAGE |&gt;\n  group_by(Agency) |&gt;\n  summarize(Total_VRM = sum(Vehicle_Miles, na.rm = TRUE)) |&gt;\n  arrange(desc(Total_VRM)) |&gt;\n  datatable(\n    options = list(pageLength = 1, dom = \"t\"), # Only display top row\n    rownames = FALSE\n  ) |&gt;\n  formatRound(\"Total_VRM\", digits = 0, mark = \",\")\n\n\n\n\n\n\n\n2. What transit mode had the most total VRM in this sample?\n\nUSAGE |&gt;\n  group_by(Mode) |&gt;\n  summarize(Total_VRM = sum(Vehicle_Miles, na.rm=TRUE)) |&gt;\n  arrange(desc(Total_VRM)) |&gt;\n  datatable(options = list(pageLength = 1, dom = 't'),  # Only display top row\n          rownames = FALSE) |&gt; \n  formatRound(\"Total_VRM\", digits = 0, mark = \",\")\n\n\n\n\n\n\n\n3. How many trips were taken on the NYC Subway (Heavy Rail) in May 2024?\n\ntotal_trips &lt;- USAGE |&gt;\n  filter(Agency == \"MTA New York City Transit\", Mode == \"Heavy Rail\", month == \"2024-05-01\") |&gt;\n  summarize(Total_Trips = sum(Passenger_Trips, na.rm = TRUE)) |&gt;\n  pull(Total_Trips)\n\nmessage &lt;- sprintf(\n  \"There were %s trips taken on the NYC Subway (Heavy Rail) in May 2024.\",\n  format(total_trips, big.mark = \",\")\n)\n\ncat(message)\n\nThere were 180,458,819 trips taken on the NYC Subway (Heavy Rail) in May 2024.\n\n\n\n\n5. How much did NYC subway ridership fall between April 2019 and April 2020?\nTo solve this, we will first find ridership for 2019 and 2020 separately. Then we will subtract to get change and get percentage.\n\n# Filter and summarize data for April 2019\napril_2019 &lt;- USAGE |&gt;\n  filter(Agency == \"MTA New York City Transit\", Mode == \"Heavy Rail\", month == \"2019-04-01\") |&gt;\n  summarize(Total_Trips_2019 = sum(Passenger_Trips, na.rm = TRUE)) |&gt;\n  pull(Total_Trips_2019)\n\n# Filter and summarize data for April 2020\napril_2020 &lt;- USAGE |&gt;\n  filter(Agency == \"MTA New York City Transit\", Mode == \"Heavy Rail\", month == \"2020-04-01\") |&gt;\n  summarize(Total_Trips_2020 = sum(Passenger_Trips, na.rm = TRUE)) |&gt;\n  pull(Total_Trips_2020)\n\n# Calculate the absolute difference and percentage drop\nridership_difference &lt;- april_2019 - april_2020\npercentage_drop &lt;- (ridership_difference / april_2019) * 100\n\n# Print the custom message with the result and percentage drop\nmessage &lt;- sprintf(\n  \"NYC subway ridership fell by %s trips between April 2019 and April 2020, which is a %.2f%% decrease.\",\n  format(ridership_difference, big.mark = \",\"), percentage_drop\n)\n\ncat(message)\n\nNYC subway ridership fell by 211,969,660 trips between April 2019 and April 2020, which is a 91.28% decrease.\n\n\n\n\n\n\n\n\n\n\n\nTask 4: Explore and Analyze\n\n\n\nFind three more interesting transit facts in this data other than those above.\n\n1. Top 5 Transit Agencies by Total Passenger Trips\n\nUSAGE |&gt;\n  group_by(Agency) |&gt;\n  summarize(Total_Trips = sum(Passenger_Trips, na.rm = TRUE)) |&gt;\n  arrange(desc(Total_Trips)) |&gt;\n  head(5) |&gt;\n  datatable(options = list(pageLength = 5, dom = \"t\"), rownames = FALSE) |&gt;\n  formatRound(\"Total_Trips\", digits = 0, mark = \",\")\n\n\n\n\n\n\n\n2. Top 5 Transit Modes by Total Vehicle Miles\n\ntop_modes_vrm &lt;- USAGE |&gt;\n  group_by(Mode) |&gt;\n  summarize(Total_VRM = sum(Vehicle_Miles, na.rm = TRUE)) |&gt;\n  arrange(desc(Total_VRM)) |&gt;\n  head(5)\n\ndatatable(top_modes_vrm, options = list(pageLength = 5, dom = \"t\"), rownames = FALSE) |&gt;\n  formatRound(\"Total_VRM\", digits = 0, mark = \",\")\n\n\n\n\n\n\n\n3. Top 5 Agencies with Largest Decrease in Ridership between 2019 and 2020\n\nridership_decline &lt;- USAGE |&gt;\n  group_by(Agency) |&gt;\n  summarize(\n    Trips_2019 = sum(ifelse(month == \"2019-04-01\", Passenger_Trips, NA), na.rm = TRUE),\n    Trips_2020 = sum(ifelse(month == \"2020-04-01\", Passenger_Trips, NA), na.rm = TRUE)\n  ) |&gt;\n  mutate(Decline = Trips_2019 - Trips_2020) |&gt;\n  arrange(desc(Decline)) |&gt;\n  head(5)\n\ndatatable(ridership_decline, options = list(pageLength = 5, dom = \"t\"), rownames = FALSE) |&gt;\n  formatRound(c(\"Trips_2019\", \"Trips_2020\", \"Decline\"), digits = 0, mark = \",\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTask 5: Table Summarization\n\n\n\nCreate a new table from USAGE that has annual total (sum) UPT and VRM for 2022. This will require use of the group_by, summarize, and filter functions. You will also want to use the year function, to extract a year from the month column.\nThe resulting table should have the following columns:\n\nNTD ID\nAgency\nmetro_area\nMode\nUPT\nVRM\n\nMake sure to ungroup your table after creating it.\nName this table USAGE_2022_ANNUAL.\nThis will be done with following command.\n\n# Create the USAGE_2022_ANNUAL table\nUSAGE_2022_ANNUAL &lt;- USAGE |&gt;\n  # Extract the year from the month column\n  mutate(year = year(month)) |&gt;\n  # Filter for the year 2022\n  filter(year == 2022) |&gt;\n  # Group by the necessary columns\n  group_by(`NTD ID`, Agency, metro_area, Mode) |&gt;\n  # Summarize total UPT and VRM for the year\n  summarize(UPT = sum(Passenger_Trips, na.rm = TRUE), VRM = sum(Vehicle_Miles, na.rm = TRUE)) |&gt;\n  # Ungroup the table\n  ungroup()\n\nLet’s verify that all the columns are there.\n\ncat(colnames(USAGE_2022_ANNUAL), sep = \"\\n\")\n\nNTD ID\nAgency\nmetro_area\nMode\nUPT\nVRM\n\n\n\n\nNow, Let’s join with FINANCIALS to create single table and create USAGE_AND_FINANCIALS. However, before joining, let’s view the table Financials:\n\nFINANCIALS |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nHere we notice that Mode is Acronym. However, USAGE_2022_ANNUAL doesn’t have acronyms. To make sure we can join both the table, let’s change FINANCIALS mode to match USAGE_2022_ANNUAL.\n\nFINANCIALS &lt;- FINANCIALS |&gt;\n  mutate(Mode = case_when(\n    Mode == \"DR\" ~ \"Demand Response\",\n    Mode == \"FB\" ~ \"Ferryboat\",\n    Mode == \"MB\" ~ \"Motorbus\",\n    Mode == \"SR\" ~ \"Streetcar Rail\",\n    Mode == \"TB\" ~ \"Trolleybus\",\n    Mode == \"VP\" ~ \"Vanpool\",\n    Mode == \"CB\" ~ \"Commuter Bus\",\n    Mode == \"RB\" ~ \"Bus Rapid Transit\",\n    Mode == \"LR\" ~ \"Light Rail\",\n    Mode == \"YR\" ~ \"Hybrid Rail\",\n    Mode == \"MG\" ~ \"Monorail/Automated Guideway\",\n    Mode == \"CR\" ~ \"Commuter Rail\",\n    Mode == \"AR\" ~ \"Alaska Railroad\",\n    Mode == \"TR\" ~ \"Aerial Tramway\",\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"IP\" ~ \"Inclined Plane\",\n    Mode == \"PB\" ~ \"Publico\",\n    Mode == \"CC\" ~ \"Cable Car\",\n    TRUE ~ \"Unknown\"\n  ))\n\nNow, let’s join to create USAGE_AND_FINANCIALS. We will join NTD ID and Mode as they are present in both the tables to create USAGE_AND_FINANCIALS.\n\n USAGE_AND_FINANCIALS &lt;- left_join(\n  USAGE_2022_ANNUAL,\n  FINANCIALS,\n  join_by(`NTD ID`, Mode)\n) |&gt;\n  drop_na()\n\nLet’s view few records to make sure we have them:\n\nUSAGE_AND_FINANCIALS |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nBefore we answer the questions, we will rename few columns to make them more readable:\n\nUSAGE_AND_FINANCIALS &lt;- USAGE_AND_FINANCIALS |&gt;\n  rename(Passenger_Trips = UPT, Vehicle_Miles = VRM)\n\n\n\n\n\n\n\nTask 6: Farebox Recovery Among Major Systems\n\n\n\nUsing the USAGE_AND_FINANCIALS table, answer the following questions:\n\n1. Which transit system (agency and mode) had the most UPT in 2022?\n\n USAGE_AND_FINANCIALS |&gt;\n  select(Agency, Mode, Passenger_Trips) |&gt;\n  arrange(desc(Passenger_Trips)) |&gt;\n  datatable(\n    options = list(pageLength = 1, dom = \"t\"), # Only display top row\n    rownames = FALSE\n  ) |&gt;\n  formatRound(\"Passenger_Trips\", digits = 0, mark = \",\")\n\n\n\n\n\n\n\n2. Which transit system (agency and mode) had the highest farebox recovery (Total Fares to Expenses)?\n\n    USAGE_AND_FINANCIALS |&gt;\n  mutate(Farebox_Recovery = `Total Fares` / Expenses) |&gt;\n  filter(!is.na(`Expenses`) &`Expenses`&gt;0) |&gt;\n  arrange(desc(Farebox_Recovery)) |&gt;\n  select(Agency, Mode, Farebox_Recovery) |&gt;\n  datatable(\n    options = list(pageLength = 1, dom = \"t\"), # Only display top row\n    rownames = FALSE\n  ) |&gt;\n  formatRound(\"Farebox_Recovery\", mark = \",\")\n\n\n\n\n\n\n\n3 Which transit system (agency and mode) has the lowest expenses per UPT?\n\n  USAGE_AND_FINANCIALS |&gt;\n  mutate(Expenses_per_UPT = Expenses / Passenger_Trips) |&gt;\n  arrange(Expenses_per_UPT) |&gt;\n  select(Agency, Mode, Expenses_per_UPT) |&gt;\n  datatable(\n    options = list(pageLength = 1, dom = \"t\"), # Only display top row\n    rownames = FALSE\n  ) |&gt;\n  formatRound(\"Expenses_per_UPT\", mark = \",\")\n\n\n\n\n\n\n\n4. Which transit system (agency and mode) has the highest total fares per UPT?\n\n  USAGE_AND_FINANCIALS |&gt;\n   mutate(Fares_per_UPT = `Total Fares` / Passenger_Trips) |&gt;\n   arrange(desc(Fares_per_UPT)) |&gt;\n   select(Agency, Mode, Fares_per_UPT) |&gt;\n   datatable(\n     options = list(pageLength = 1, dom = \"t\"), # Only display top row\n     rownames = FALSE\n   ) |&gt;\n   formatRound(\"Fares_per_UPT\", mark = \",\")\n\n\n\n\n\n\n\n5. Which transit system (agency and mode) has the lowest expenses per VRM?\n\n  USAGE_AND_FINANCIALS |&gt;\n   mutate(Expenses_per_VRM = Expenses / Vehicle_Miles) |&gt;\n   arrange(Expenses_per_VRM) |&gt;\n   select(Agency, Mode, Expenses_per_VRM) |&gt;\n   datatable(\n     options = list(pageLength = 1, dom = \"t\"), # Only display top row\n     rownames = FALSE\n   ) |&gt;\n   formatRound(\"Expenses_per_VRM\", mark = \",\")\n\n\n\n\n\n\n\n6. Which transit system (agency and mode) has the highest total fares per VRM?\n\n  USAGE_AND_FINANCIALS |&gt;\n  mutate(Fares_per_VRM = `Total Fares` / Vehicle_Miles) |&gt;\n  arrange(desc(Fares_per_VRM)) |&gt;\n  select(Agency, Mode, Fares_per_VRM) |&gt;\n  datatable(\n    options = list(pageLength = 1, dom = \"t\"), # Only display top row\n    rownames = FALSE\n  ) |&gt;\n  formatRound(\"Fares_per_VRM\", mark = \",\")"
  },
  {
    "objectID": "mp01.html#conclusion",
    "href": "mp01.html#conclusion",
    "title": "Transit Data Analysis",
    "section": "Conclusion",
    "text": "Conclusion\nIn my view, the Transit Authority of Central Kentucky’s Vanpool stands out as the most efficient transit system due to its farebox recovery ratio exceeding 100%, meaning it generates more fare revenue than its operating costs. This high level of financial self-sufficiency is uncommon in public transit and makes it highly efficient from a financial sustainability perspective.\nOverall, this was an interesting assignment to understand basics DT operations using Transportation data. This analysis provided valuable insights into the financial and operational performance of different transit agencies and modes."
  },
  {
    "objectID": "mp01.html#key-points-from-this-analysis",
    "href": "mp01.html#key-points-from-this-analysis",
    "title": "Transit Data Analysis",
    "section": "Key points from this analysis",
    "text": "Key points from this analysis\n\nMTA New York City Transit had the most passenger trips in 2022.\nNYC Subway saw a 91.28% drop in ridership between April 2019 and April 2020 due to COVID-19.\nTransit Authority of Central Kentucky’s Vanpool had the highest farebox recovery, covering costs effectively through fare revenue.\nNorth Carolina State University’s Motorbus service had the lowest expenses per passenger trip.\nThe Motorbus mode, across all agencies, is the one that collects the most fare revenue for every mile the buses travel while carrying passengers.\nThe transit system with the highest total fares per Vehicle Revenue Mile is the Chicago Water Taxi in the Ferryboat mode."
  },
  {
    "objectID": "mp02.html",
    "href": "mp02.html",
    "title": "Mini Project 02",
    "section": "",
    "text": "Introduction\nThe goal of this project is to leverage data-driven insights to identify the key characteristics of successful movies and develop a compelling proposal for a new film. By analyzing historical IMDb data on movie ratings, genres, and key personnel, we aim to guide creative decisions with statistical evidence, ultimately proposing a high-potential movie idea that aligns with current industry trends and audience preferences.please refer to: Mini-Project #02\n\n\nData Sources\nData from the The IMDb non-commercial release can be used for this project. Specifically, which are made freely available for non-commercial use, provide comprehensive information about films, including ratings, genres, and key personnel, allowing for analysis of historical trends and the development of a data-driven movie proposal.\nThe IMDb dataset was initially too large, so for this project, a pre-processed and downsized version provided by the professor on GitHub. This version retains the essential information but is optimized for more manageable data analysis in R, allowing us to run the necessary tasks more efficiently without overloading system resources.\n\n\nData Description\nThe data includes comprehensive information about movies, such as ratings, genres, and key personnel. The dataset consists of multiple tables:\nname_basics_small: Contains information about actors, directors, and other personnel.\ntitle_basics_small: Provides basic movie details like title, genre, and release year.\ntitle_ratings_small: Contains IMDb user ratings and vote counts for movies.\ntitle_crew_small: Includes data on directors and writers for each title.\ntitle_principals_small: Details about the key actors and their roles in each movie.\ntitle_episodes_small: Contains data on TV episodes related to series.\n\n\nLoading Packages\nOnce the packages are installed, those will be loaded to the workspace so that they can be used later.\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(readr)\nlibrary(lubridate)\nlibrary(DT)\nlibrary(tidyr)\nlibrary(data.table)\n\n\n\nLoad Data\nUsing the following code, I manage to download and process of the IMDb datasets, including name.basics, title.basics, title.episode, title.ratings, title.crew, and title.principals.\n\nget_imdb_file &lt;- function(fname) {\n  BASE_URL &lt;- \"https://github.com/michaelweylandt/STA9750/tree/main/miniprojects/mini02_preprocessed/\"\n  fname_ext &lt;- paste0(fname, \".csv.zip\")\n  rds_file &lt;- paste0(fname, \".rds\")\n\n  # Check if the .rds file already exists\n  if (file.exists(rds_file)) {\n    return(readRDS(rds_file)) # Load the data from the saved .rds file\n  } else {\n    # Download only if the .tsv.gz file does not exist\n    if (!file.exists(fname_ext)) {\n      FILE_URL &lt;- paste0(BASE_URL, fname_ext)\n      download.file(FILE_URL, destfile = fname_ext, mode = \"wb\") # Ensure binary mode for downloading compressed files\n    }\n    \n    # Use data.table::fread for faster reading\n    df &lt;- as.data.frame(fread(fname_ext))\n    saveRDS(df, rds_file, compress = FALSE)\n    return(df)\n  }\n}\n\n\n# Load IMDb data\nNAME_BASICS &lt;- get_imdb_file(\"name_basics_small\")\nTITLE_BASICS &lt;- get_imdb_file(\"title_basics_small\")\nTITLE_RATINGS &lt;- get_imdb_file(\"title_ratings_small\")\nTITLE_EPISODES &lt;- get_imdb_file(\"title_episodes_small\")\nTITLE_CREW &lt;- get_imdb_file(\"title_crew_small\")\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title_principals_small\")\n\n\n\nData Sampling\nGiven the size of the data, we began by down-selecting to create a more manageable dataset for analysis. We will only select actors who are known for more than 1 movie/show.\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n  filter(str_count(knownForTitles, \",\") &gt; 1)\n\n\n\nData Visualization\nWe visualize key metrics to gain insights. For example, we create histograms of IMDb ratings to see the distribution of ratings across movies.\n\nTITLE_RATINGS |&gt;\n  ggplot(aes(x = numVotes)) +\n  geom_histogram(bins = 30) +\n  xlab(\"Number of IMDB Ratings\") +\n  ylab(\"Number of Titles\") +\n  ggtitle(\"Majority of IMDB Titles Have Less than 1000 Ratings\") +\n  theme_bw() +\n  scale_x_log10(label = scales::comma) +\n  scale_y_continuous(label = scales::comma)\n\n\n\n\n\n\n\n\n\n\nData Cleaning\nNow, let’s filter and join the IMDb datasets, correct column types, and clean the data for analysis by ensuring numeric and logical fields are properly formatted.\n\nTITLE_RATINGS |&gt;\n  pull(numVotes) |&gt;\n  quantile()\n\n     0%     25%     50%     75%    100% \n    100     165     332     970 2942823 \n\n\nNow, let’s only keep records that have atleast 100 records\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n  filter(numVotes &gt;= 100)\n\nNow, semi_join will be used to keep records that are present in title_rating. This will help will reducing the size of data.\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n  semi_join(\n    TITLE_RATINGS,\n    join_by(tconst == tconst)\n  )\n\nTITLE_CREW &lt;- TITLE_CREW |&gt;\n  semi_join(\n    TITLE_RATINGS,\n    join_by(tconst == tconst)\n  )\n\nTITLE_EPISODES_1 &lt;- TITLE_EPISODES |&gt;\n  semi_join(\n    TITLE_RATINGS,\n    join_by(tconst == tconst)\n  )\nTITLE_EPISODES_2 &lt;- TITLE_EPISODES |&gt;\n  semi_join(\n    TITLE_RATINGS,\n    join_by(parentTconst == tconst)\n  )\n\nTITLE_EPISODES &lt;- bind_rows(\n  TITLE_EPISODES_1,\n  TITLE_EPISODES_2\n) |&gt;\n  distinct()\n\nTITLE_PRINCIPALS &lt;- TITLE_PRINCIPALS |&gt;\n  semi_join(TITLE_RATINGS, join_by(tconst == tconst))\n\n\n# Following are not used. Removing\nrm(TITLE_EPISODES_1)\nrm(TITLE_EPISODES_2)\n\n\n\nData Cleaning before Task 1\nWe use mutate and as.numeric to convert string values in the NAME_BASICS birthYear and deathYear columns to numeric format for proper analysis.\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n  mutate(\n    birthYear = as.numeric(birthYear),\n    deathYear = as.numeric(deathYear)\n  )\n\n# Let's view data now. \nglimpse(NAME_BASICS)\n\nRows: 2,460,608\nColumns: 6\n$ nconst            &lt;chr&gt; \"nm0000001\", \"nm0000002\", \"nm0000003\", \"nm0000004\", …\n$ primaryName       &lt;chr&gt; \"Fred Astaire\", \"Lauren Bacall\", \"Brigitte Bardot\", …\n$ birthYear         &lt;dbl&gt; 1899, 1924, 1934, 1949, 1918, 1915, 1899, 1924, 1925…\n$ deathYear         &lt;dbl&gt; 1987, 2014, NA, 1982, 2007, 1982, 1957, 2004, 1984, …\n$ primaryProfession &lt;chr&gt; \"actor,miscellaneous,producer\", \"actress,soundtrack,…\n$ knownForTitles    &lt;chr&gt; \"tt0072308,tt0050419,tt0053137,tt0027125\", \"tt003738…\n\n\n\n\n\n\n\n\nTask 1: Column Type Correction\n\n\n\nCorrect the column types of the TITLE tables using a combination of mutate and the coercion functions as.numeric and as.logical.\n\n\nNow, we will examine the dataset using glimpse and clean the data by converting columns in TITLE_BASICS and TITLE_EPISODES to numeric and boolean types, and split knownForTitles in NAME_BASICS for further analysis.\n\nglimpse(TITLE_BASICS)\n\nRows: 372,198\nColumns: 9\n$ tconst         &lt;chr&gt; \"tt0000001\", \"tt0000002\", \"tt0000003\", \"tt0000004\", \"tt…\n$ titleType      &lt;chr&gt; \"short\", \"short\", \"short\", \"short\", \"short\", \"short\", \"…\n$ primaryTitle   &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Pauvre Pierrot…\n$ originalTitle  &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Pauvre Pierrot…\n$ isAdult        &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ startYear      &lt;chr&gt; \"1894\", \"1892\", \"1892\", \"1892\", \"1893\", \"1894\", \"1894\",…\n$ endYear        &lt;chr&gt; \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\",…\n$ runtimeMinutes &lt;chr&gt; \"1\", \"5\", \"5\", \"12\", \"1\", \"1\", \"1\", \"1\", \"45\", \"1\", \"1\"…\n$ genres         &lt;chr&gt; \"Documentary,Short\", \"Animation,Short\", \"Animation,Come…\n\n\nAs we can see, isAdult can be boolean. Startyear, endYear, runTimeMinutes can be numbers.\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n  mutate(\n    startYear = as.numeric(startYear),\n    endYear = as.numeric(endYear),\n    runtimeMinutes = as.numeric(runtimeMinutes),\n    isAdult = as.logical(isAdult)\n  )\n\nNow, let’s do some data cleaning for other tables. Starting with TITLE_EPISODES\n\nglimpse(TITLE_EPISODES)\n\nRows: 3,007,178\nColumns: 4\n$ tconst        &lt;chr&gt; \"tt0045960\", \"tt0046855\", \"tt0048378\", \"tt0048562\", \"tt0…\n$ parentTconst  &lt;chr&gt; \"tt0044284\", \"tt0046643\", \"tt0047702\", \"tt0047768\", \"tt0…\n$ seasonNumber  &lt;chr&gt; \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"…\n$ episodeNumber &lt;chr&gt; \"3\", \"4\", \"6\", \"10\", \"4\", \"20\", \"5\", \"2\", \"20\", \"6\", \"2\"…\n\n\nIt can be seen that seasonNumber and Episode Number are numbers. Converting those:\n\nTITLE_EPISODES &lt;- TITLE_EPISODES |&gt;\n  mutate(\n    seasonNumber = as.numeric(seasonNumber),\n    episodeNumber = as.numeric(episodeNumber)\n  )\n\nNAME_BASICS will be analyzed next.\n\nglimpse(NAME_BASICS)\n\nRows: 2,460,608\nColumns: 6\n$ nconst            &lt;chr&gt; \"nm0000001\", \"nm0000002\", \"nm0000003\", \"nm0000004\", …\n$ primaryName       &lt;chr&gt; \"Fred Astaire\", \"Lauren Bacall\", \"Brigitte Bardot\", …\n$ birthYear         &lt;dbl&gt; 1899, 1924, 1934, 1949, 1918, 1915, 1899, 1924, 1925…\n$ deathYear         &lt;dbl&gt; 1987, 2014, NA, 1982, 2007, 1982, 1957, 2004, 1984, …\n$ primaryProfession &lt;chr&gt; \"actor,miscellaneous,producer\", \"actress,soundtrack,…\n$ knownForTitles    &lt;chr&gt; \"tt0072308,tt0050419,tt0053137,tt0027125\", \"tt003738…\n\n\nIt can be seen that knownForTitles column contains multiple comma separated records. We can use the separate_longer_delim function to break these into multiple rows.\n\nNAME_BASICS |&gt;\n  separate_longer_delim(knownForTitles, \",\") |&gt;\n  slice_head(n = 10)\n\n      nconst     primaryName birthYear deathYear\n1  nm0000001    Fred Astaire      1899      1987\n2  nm0000001    Fred Astaire      1899      1987\n3  nm0000001    Fred Astaire      1899      1987\n4  nm0000001    Fred Astaire      1899      1987\n5  nm0000002   Lauren Bacall      1924      2014\n6  nm0000002   Lauren Bacall      1924      2014\n7  nm0000002   Lauren Bacall      1924      2014\n8  nm0000002   Lauren Bacall      1924      2014\n9  nm0000003 Brigitte Bardot      1934        NA\n10 nm0000003 Brigitte Bardot      1934        NA\n                    primaryProfession knownForTitles\n1        actor,miscellaneous,producer      tt0072308\n2        actor,miscellaneous,producer      tt0050419\n3        actor,miscellaneous,producer      tt0053137\n4        actor,miscellaneous,producer      tt0027125\n5  actress,soundtrack,archive_footage      tt0037382\n6  actress,soundtrack,archive_footage      tt0075213\n7  actress,soundtrack,archive_footage      tt0117057\n8  actress,soundtrack,archive_footage      tt0038355\n9   actress,music_department,producer      tt0057345\n10  actress,music_department,producer      tt0049189\n\n\n\n\n\n\n\n\nTask 2: Instructor-Provided Questions\n\n\n\n\n\n\n\n\n2.1. How many movies, TV series, and TV episodes are in the data set?\nWe calculate the total number of movies, TV series, and TV episodes after removing records with less than 100 ratings.\n\n# Count movies, TV series, and TV episodes\nresult &lt;- TITLE_BASICS |&gt;\n  group_by(titleType) |&gt;\n  summarise(count = n())\n\n# Now lets make a message\nmessage &lt;- sprintf(\n  \"The dataset contains %d movies, %d TV series, and %d TV episodes.\",\n  result$count[result$titleType == \"movie\"],\n  result$count[result$titleType == \"tvSeries\"],\n  result$count[result$titleType == \"tvEpisode\"]\n)\n\ncat(message)\n\nThe dataset contains 131662 movies, 29789 TV series, and 155722 TV episodes.\n\n\n\n\n2.2. Who is the oldest living person in our data set?\nWe find the oldest living person by filtering for those with missing death years and sorting by birth year. However, we need to make sure that are not including records before 1900 as they might be missing.\n\n# Find the oldest living person, born after a reasonable cutoff (e.g., 1900)\noldest_person &lt;- NAME_BASICS |&gt;\n  filter(is.na(deathYear)) |&gt; # Only living people\n  filter(!is.na(birthYear)) |&gt; # Exclude missing birth years\n  filter(birthYear &gt;= 1900) |&gt; # Consider only people born after 1900\n  arrange(birthYear) |&gt; # Sort by birth year\n  head(1) # Get the oldest person\n\n# Calculate current age\ncurrent_year &lt;- as.numeric(format(Sys.Date(), \"%Y\"))\noldest_person_age &lt;- current_year - oldest_person$birthYear\n\n# Create a dynamic message\nmessage &lt;- sprintf(\n  \"The oldest living person in the dataset is %s, born in %d. They are currently %d years old.\",\n  oldest_person$primaryName,\n  oldest_person$birthYear,\n  oldest_person_age\n)\n\ncat(message)\n\nThe oldest living person in the dataset is Léonide Azar, born in 1900. They are currently 124 years old.\n\n\n\n\n2.3. Find the TV episode with 10/10 rating and 200,000 ratings\nWe use filtering and joins to identify highly rated TV episodes.\n\n# Step 1: Find the TV episode with a 10/10 rating and at least 200,000 votes\ntop_rated_episode &lt;- TITLE_RATINGS |&gt;\n  filter(averageRating == 10, numVotes &gt;= 200000) |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\") |&gt;\n  head(1)\n\n\nmessage &lt;- sprintf(\n    \"The top-rated TV episode is %s with %d votes and a perfect 10/10 rating.\",\n    top_rated_episode$primaryTitle,\n    top_rated_episode$numVotes\n  )\n\n\n# Print the message\ncat(message)\n\nThe top-rated TV episode is Ozymandias with 227589 votes and a perfect 10/10 rating.\n\n\n\n\n2.4. What four projects is the actor Mark Hamill most known for?\n\nmark_hamill &lt;- NAME_BASICS |&gt;\n  filter(primaryName == \"Mark Hamill\") |&gt;\n  pull(knownForTitles)\n\n\ntconsts &lt;- unlist(strsplit(mark_hamill, \",\"))\n\n\nTITLE_BASICS |&gt;\n  filter(tconst %in% tconsts) |&gt;\n  select(primaryTitle, titleType, startYear) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n2.5. TV series with more than 12 episodes and the highest average rating\n\n# Filter for TV episodes with ratings and join with TITLE_BASICS\nepisode_ratings &lt;- TITLE_EPISODES |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  inner_join(TITLE_BASICS, by = c(\"parentTconst\" = \"tconst\"))\n\n# Count episodes per series and filter for series with more than 12 episodes\ntop_rated_series &lt;- episode_ratings |&gt;\n  group_by(parentTconst, primaryTitle) |&gt;\n  summarise(\n    avg_rating = mean(averageRating, na.rm = TRUE),\n    num_episodes = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  filter(num_episodes &gt; 12) |&gt;\n  arrange(desc(avg_rating)) |&gt;\n  head(1)\n\nmessage &lt;- sprintf(\n    \"The TV series with the highest average rating is %s with an average rating of %.2f across %d episodes.\",\n    top_rated_series$primaryTitle,\n    top_rated_series$avg_rating,\n    top_rated_series$num_episodes\n  )\ncat(message)\n\nThe TV series with the highest average rating is Kavya - Ek Jazbaa, Ek Junoon with an average rating of 9.75 across 113 episodes.\n\n\n\n\n2.6. Is it true that episodes from later seasons of Happy Days have lower average ratings than the early seasons?\n\nlibrary(ggplot2)\n\n# Find all episodes of Happy Days\nhappy_days &lt;- TITLE_BASICS |&gt;\n  filter(primaryTitle == \"Happy Days\")\n\n# Join with episodes and ratings\nhappy_days_ratings &lt;- TITLE_EPISODES |&gt;\n  filter(parentTconst %in% happy_days$tconst) |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  group_by(seasonNumber) |&gt;\n  summarise(avg_rating = mean(averageRating, na.rm = TRUE)) |&gt;\n  arrange(seasonNumber)\n\n# Create a line graph to visualize the average ratings by season\nggplot(happy_days_ratings, aes(x = seasonNumber, y = avg_rating)) +\n  geom_line(color = \"pink\") + \n  geom_point(color = \"red\") +\n  labs(\n    title = \"Average Ratings of Happy Days by Season\",\n    x = \"Season Number\",\n    y = \"Average Rating\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nBased on the results, it does appear that later seasons of Happy Days generally have lower average ratings than the earlier seasons:\n\nSeasons 1 through 3 have relatively high ratings, all around or above 7.5.\nStarting from Season 4, there is a noticeable decline, with Season 8 reaching a low of 5.3.\nThere is a small improvement in Seasons 9 to 11, but they remain lower compared to the earlier seasons.\n\nThis confirms that later seasons, particularly after Season 3, tend to have lower average ratings compared to the earlier ones, supporting the hypothesis that the quality of the show may have declined in its later years\n\n\n\n\n\n\nTask 3: Custom Success Metric\n\n\n\n\n\n\n\n\n3.1. Choose the top 5-10 movies on your m-0[] that combines IMDb ratings with the number of votes. We define success as follows:\nA success metric is a way to measure how well something has performed, in this case, movies. For your project, we want to measure both the quality of a movie (how good people think it is) and its popularity (how many people have seen and rated it).\nWe use two key pieces of information from IMDb:\n\nAverage IMDb Rating: This tells us how good the movie is, based on the ratings it has received.\nNumber of Votes: This tells us how many people rated the movie, which helps us understand how popular it is.\n\nTo create the success metric, we combine these two things in a formula:\nSuccess Metric = Average IMDb Rating * log10(Number of Votes)\n\nThe average rating shows how much people liked the movie.\nThe logarithm of the number of votes is used to make sure that popular movies with lots of ratings get credit for being well-known, but without letting movies with lots of votes (but mediocre ratings) dominate.\n\nOverall, this will look for movies that are both highly rated and widely popular, and this formula helps to rank movies based on both factors. The higher the success metric, the more successful the movie is considered.\nLet’s add a column-success_metric to store the new metric.\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log10(numVotes))\n\n\n\n3.1. Choose the top 5-10 movies on your metric and confirm that they were indeed box office successes.\n\nmovies_only &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"movie\")\n\n# Add a custom success metric to the movies_ratings table\nmovies_ratings &lt;- TITLE_RATINGS |&gt;\n  inner_join(movies_only, by = \"tconst\")\n\n\n# View the top 10 movies by success_metric\nmovies_ratings |&gt;\n  arrange(desc(success_metric)) |&gt;\n  head(10) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric) |&gt;\n  DT::datatable()\n\n\n\n\n\nThese are the top 10 movies on my metric and they are commercially successful movies.\n\n\n3.2. Choose 3-5 movies with large numbers of IMDb votes that score poorly on your success metric and confirm that they are indeed of low quality.\n\n# Select 3-5 movies with a high number of votes but low success metric\nmovies_ratings |&gt;\n  filter(numVotes &gt; 100000) |&gt; # Filter for popular movies\n  arrange(success_metric) |&gt; # Sort by lowest success metric\n  head(5) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric) |&gt;\n  DT::datatable()\n\n\n\n\n\nThese are top 5 movies with high number of votes but low success metric, indicating low-quality popular movies.\n\n\n3.3. Choose a prestige actor or director and confirm that they have many projects with high scores on your success metric.\nFor this question let’s go with famous Director Steven Spielberg.\n\n# Filter for Steven Spielberg in the NAME_BASICS table\nspielberg_nconst &lt;- NAME_BASICS |&gt;\n  filter(primaryName == \"Steven Spielberg\") |&gt;\n  pull(nconst)\n\n# Filter TITLE_CREW for movies directed by Steven Spielberg\nspielberg_projects &lt;- TITLE_CREW |&gt;\n  filter(directors == spielberg_nconst) # Spielberg's nconst from the previous step\n\n# Join with TITLE_BASICS to get movie titles\nspielberg_movies &lt;- spielberg_projects |&gt;\n  inner_join(movies_ratings, by = \"tconst\") # Join with the ratings table to get success metric\n\n# Arrange by success metric to see top movies\nspielberg_movies |&gt;\n  arrange(desc(success_metric)) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric) |&gt;\n  DT::datatable()\n\n\n\n\n\nThis table shows a prestige director-Steven Spielberg with many projects having high success metrics, indicating a consistently successful career in terms of popularity and quality.\n\n\n3.4. Perform at least one other form of ‘spot check’ validation.\n\n# Split genres into multiple rows\n# Define blockbusters as movies with over 200,000 votes\nmovies_by_type &lt;- TITLE_RATINGS |&gt;\n  mutate(movie_type = ifelse(numVotes &gt;= 200000, \"Blockbuster\", \"Independent\")) |&gt;\n  group_by(movie_type) |&gt;\n  summarise(\n    avg_success_metric = mean(success_metric, na.rm = TRUE),\n    num_movies = n(),\n    .groups = \"drop\"\n  )\n\n# View the result\nmovies_by_type |&gt;\n  DT::datatable()\n\n\n\n\n\n\nInterpretation:\nBlockbusters Tend to Have Higher Success: It’s expected that blockbuster movies score higher on the success metric because they usually attract a larger number of votes and typically have bigger production budgets, more marketing, and wider releases, leading to more exposure.The higher score (41.36) for blockbusters reflects their broad popular awareness combined with high ratings.\nIndependent Films: While independent films have a much lower average success score (18.25), they are still in large numbers. Independent films tend to have smaller audiences and therefore fewer ratings, which impacts their success metric.\n\n\n\n3.5. Come up with a numerical threshold for a project to be a ‘success’; that is, determine a value such that movies above are all “solid” or better.\nThe logic behind determining successful movies was to first calculate the quantiles of the success_metric to understand its distribution. We selected the 90th percentile as the success threshold, meaning only the top 10% of movies would be considered “successful.” Then, we filtered the dataset based on this threshold, allowing us to focus on high-performing movies for further analysis.\n\n# Determine quantiles for success_metric\nquantile(movies_ratings$success_metric, probs = seq(0, 1, by = 0.05))\n\n       0%        5%       10%       15%       20%       25%       30%       35% \n 2.068186  8.611309 10.187988 11.248161 12.058833 12.761020 13.412522 14.017286 \n      40%       45%       50%       55%       60%       65%       70%       75% \n14.604024 15.214337 15.854272 16.539468 17.309076 18.185141 19.151397 20.321881 \n      80%       85%       90%       95%      100% \n21.707109 23.449321 25.858492 29.826115 60.159507 \n\n\nSince 95% of movies have less than 25.85 rating, let’s consider this as a success threshold(v)\n\nsuccess_threshold &lt;- 25.85\n\n\n\n\n\n\n\nTask 4.Using questions like the following, identify a good “genre” for your next film. You do not need to answer these questions precisely, but these are may help guide your thinking.\n\n\n\n\n\n\n\n\nPrepare Data for Analysis\nNow, lets store popular movies. First mutate startYear as numeric, after which we will create separate records for separate genre with separate_rows and rename the genres column to genre.\n\nmovies_ratings &lt;- movies_ratings |&gt;\n  mutate(startYear = as.numeric(startYear))\n\n# Separate the genres into individual rows (some movies have multiple genres)\nmovies_genre &lt;- movies_ratings |&gt;\n  separate_rows(genres, sep = \",\")\n\n# Rename the 'genres' column to 'genre'\nmovies_genre &lt;- movies_genre |&gt;\n  rename(genre = genres)\n\nThis table will show the genre with the most successful movies in each decade. For example, “Drama” might dominate many decades, as it’s a consistently successful genre.\n\n\n4.1. What Was the Genre with the Most “Successes” in Each Decade?\n\n# Create a new column for the decade\nmovies_genre &lt;- movies_genre |&gt;\n  mutate(decade = floor(startYear / 10) * 10)\n\n# Filter for successful movies (using the threshold from earlier)\nsuccessful_movies_by_decade &lt;- movies_genre |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(decade, genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  arrange(decade, desc(num_successes))\n\n# Find the top genre in each decade\nsuccessful_movies_by_decade |&gt;\n  group_by(decade) |&gt;\n  slice_max(order_by = num_successes, n = 1) |&gt;\n  DT::datatable()\n\n\n\n\n\nLooking at the answer, it can be said that Drama is the most famous genre each decade.\n\n\n4.2. What Genre Consistently Has the Most “Successes”?\n\n# Total number of successes per genre across all decades\ntotal_successes_by_genre &lt;- movies_genre |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(genre) |&gt;\n  summarise(total_successes = n(), .groups = \"drop\") |&gt;\n  arrange(desc(total_successes))\n\ntotal_successes_by_genre |&gt;\n  DT::datatable()\n\n\n\n\n\nAs per the analysis result from this Drama Genre seems to have most success with the most numbers of suceesful Titles.\n\n\n4.3. What Genre Used to Reliably Produce “Successes” but Has Fallen Out of Favor?\nFor this, we will analyze success before 2000 and after 2000.\n\n# Successes in earlier decades (before 2000) vs recent decades (2000 and later)\nsuccess_by_era &lt;- movies_genre |&gt;\n  mutate(era = ifelse(decade &lt; 2000, \"Before 2000\", \"2000 and After\")) |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(era, genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  pivot_wider(names_from = era, values_from = num_successes, values_fill = 0) |&gt;\n  mutate(fall_out = `Before 2000` &gt; 0 & `2000 and After` == 0) |&gt;\n  filter(fall_out == TRUE)\n\nsuccess_by_era |&gt;\n  DT::datatable()\n\n\n\n\n\nAs per above result, Film-Noir seems to have zero successes after 2000.\n\n\n4.4. What Genre Has Produced the Most “Successes” Since 2010?\n\n# Filter for movies since 2010 and count successes by genre\nmovies_genre |&gt;\n  filter(startYear &gt;= 2010, success_metric &gt;= success_threshold) |&gt;\n  group_by(genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  arrange(desc(num_successes)) |&gt;\n  DT::datatable()\n\n\n\n\n\nAs per above result, Drama seems to have the most Successes after 2010.\n\n\n4.5. Does the Genre with the Most Successes Have the Highest Success Rate?\n\n# Calculate the total number of movies per genre and the number of successes\nmovies_genre |&gt;\n  group_by(genre) |&gt;\n  summarise(\n    total_movies = n(),\n    num_successes = sum(success_metric &gt;= success_threshold),\n    success_rate = num_successes / total_movies * 100,\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(success_rate)) |&gt;\n  DT::datatable()\n\n\n\n\n\nAlthough the Drama genre has most successful movies, it doesn’t seem to have the highest success rate. Biography genre has the most success rate. Drama is in 14th place when ranking by success rate.\n\n\n4.6. What Genre Has Become More Popular in Recent Years?\nTo do this analysis, we will compare movies before 2010 and after 2010.\n\nmovies_by_era &lt;- movies_genre |&gt;\n  filter(!is.na(startYear)) |&gt;  # Filter out rows with NA in startYear\n  mutate(era = ifelse(startYear &gt;= 2010, \"Post 2010\", \"Pre 2010\")) |&gt;  # Categorize movies by era\n  group_by(era, genre) |&gt;\n  summarise(num_successful_movies = n(), .groups = \"drop\") |&gt; \n  pivot_wider(names_from = era, values_from = num_successful_movies, values_fill = 0)\n\n# Calculate the absolute difference and percentage increase between eras\nmovies_by_era |&gt;\n  mutate(\n    abs_difference = `Post 2010` - `Pre 2010`,  # Absolute difference\n    percent_increase = (`Post 2010` - `Pre 2010`) / `Pre 2010` * 100  # Percentage increase\n  ) |&gt;\n  # Filter for genres with at least one movie in both eras and significant increase\n  filter(`Pre 2010` &gt; 0 & `Post 2010` &gt; 0) |&gt;\n  filter(percent_increase &gt;= 50)  |&gt;\n  select(genre, `Pre 2010`, `Post 2010`, abs_difference, percent_increase) |&gt;\n  arrange(desc(percent_increase)) |&gt;\n  head(1) |&gt;\n  DT::datatable()\n\n\n\n\n\nNews genre seems to have the highest increase in popularity.\n\n\n\n\n\n\nTask 5: Key Personnel\n\n\n\nIdentify (at least) two actors and one director who you will target as the key talent for your movie. Write a short “pitch” as to why they are likely to be successful. You should support your pitch with at least one graphic and one table.\n\n\n\n\nActors with successful movies\nLet’s list down the actors with their numbers of movies which is categorized successful.\n\n# Join TITLE_PRINCIPALS with movies_ratings to get actors with successful movies\nsuccessful_actors &lt;- TITLE_PRINCIPALS |&gt;\n  inner_join(movies_ratings, by = \"tconst\") |&gt;\n  filter(category == \"actor\" | category == \"actress\") |&gt;\n  group_by(nconst) |&gt;\n  summarise(\n    num_successful_movies = sum(success_metric &gt;= success_threshold),\n    avg_success_metric = mean(success_metric, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(num_successful_movies)) |&gt;\n  head(10)\n\n# Join with NAME_BASICS to get actor names\nsuccessful_actors &lt;- successful_actors |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, num_successful_movies, avg_success_metric)\n\nsuccessful_actors |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nThis result says that most successful actor are Samuel L. Jackson & Robert De Niro with 72 & 71 sucessful movies.\n\n\nDirectors with successful movies\nNow let’s find the most successful director with their numbers of movies which is categorized successful.\n\nsuccessful_directors &lt;- TITLE_CREW |&gt;\n  inner_join(movies_ratings, by = \"tconst\") |&gt;\n  filter(!is.na(directors)) |&gt;\n  separate_rows(directors, sep = \",\") |&gt;\n  group_by(directors) |&gt;\n  summarise(\n    num_successful_movies = sum(success_metric &gt;= success_threshold),\n    avg_success_metric = mean(success_metric, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(num_successful_movies)) |&gt;\n  head(5)\n\nsuccessful_directors &lt;- successful_directors |&gt;\n  inner_join(NAME_BASICS, by = c(\"directors\" = \"nconst\")) |&gt;\n  select(primaryName, num_successful_movies, avg_success_metric)\n\nsuccessful_directors |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nThis result says that most successful director is Woody Allen with 48 sucessful movies.\n\n\n5.1: Generate a Graphic for Actor/Director Success\n\nlibrary(ggplot2)\n\n# Combine actors and directors for visualization\nkey_talent &lt;- rbind(\n  successful_actors |&gt; head(2),\n  successful_directors |&gt; head(1)\n)\n\n# Create a bar plot for key talent success\nggplot(key_talent, aes(x = reorder(primaryName, -num_successful_movies), y = num_successful_movies)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(\n    title = \"Number of Successful Movies for Key Talent\",\n    x = \"Talent\",\n    y = \"Number of Successful Movies\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nThe graph below demonstrates that Samuel L. Jackson and Robert De Nior lead the way with the highest number of successful movies, while Woody Allen stands out as the top director in terms of successful films.\n\n\n5.2: Create a Table for Actor/Director Success\n\nif (!require(\"kableExtra\")) install.packages(\"kableExtra\")\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Add role information for actors and directors\nactors &lt;- successful_actors |&gt;\n  head(2) |&gt;\n  mutate(role = \"Actor\")\ndirectors &lt;- successful_directors |&gt;\n  head(1) |&gt;\n  mutate(role = \"Director\")\n\n# Combine actors and directors into one table\nkey_talent &lt;- rbind(actors, directors)\n\n\n# Create a table showing the role, number of successful movies, and average success metric\nkey_talent |&gt;\n  select(primaryName, role, num_successful_movies, avg_success_metric) |&gt;\n  kable(col.names = c(\"Name\", \"Role\", \"Successful Movies\", \"Average Success Metric\")) |&gt;\n  kable_styling(bootstrap_options = \"striped\", full_width = F)\n\n\n\n\nName\nRole\nSuccessful Movies\nAverage Success Metric\n\n\n\n\nSamuel L. Jackson\nActor\n72\n30.64902\n\n\nRobert De Niro\nActor\n71\n31.50732\n\n\nWoody Allen\nDirector\n48\n32.34535\n\n\n\n\n\n\n\nThe table below demonstrates that Samuel L. Jackson and Robert De Niro lead the way with the highest number of successful movies, while Woody Allen stands out as the top director in terms of successful films.\n\n\n\n\n\n\nTask 6: Finding a Classic Movie to Remake\n\n\n\n\n\n\nFind a classic movie to remake with your key talent. The original should have a large number of IMDb ratings, a high average rating, and not have been remade in the past 25 years.4\nOnce you have found your classic movie to remake, confirm whether key actors, directors, or writers from the original are still alive. If so, you need to contact your legal department to ensure they can secure the rights to the project. You may also want to include the classic actors as “fan service.”\n\n\n6.1: Filter for Classic Movies\n\n# Define the year cutoff for remakes (25 years ago)\nyear_cutoff &lt;- 1999\n\n# Filter for classic movies that haven't been remade in the last 25 years\nclassic_movies &lt;- movies_ratings |&gt;\n  filter(\n    startYear &lt; year_cutoff,\n    averageRating &gt;= 7.5,\n    numVotes &gt;= 50000\n  ) |&gt;\n  arrange(desc(averageRating))\n\nclassic_movies |&gt;\n  DT::datatable()\n\n\n\n\n\nAs per result, these are the rank for classic movies.\n\n\n6.2: Check if Original Actors Are Still Alive\n\noriginal_movie_tconst &lt;- classic_movies$tconst[1] # Example: select the first movie in the list\n\n# Find actors in the original movie\noriginal_actors &lt;- TITLE_PRINCIPALS |&gt;\n  filter(tconst == original_movie_tconst, category %in% c(\"actor\", \"actress\")) |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, birthYear, deathYear)\n\n# Filter for actors who are still alive\noriginal_actors |&gt;\n  filter(is.na(deathYear)) |&gt;\n  DT::datatable()\n\n\n\n\n\nThis result says that the these top actors are still alive.\n\n\n6.3: Check if Original Directors/writers Are Still Alive\n\n# Find directors and writers from the original movie\noriginal_crew &lt;- TITLE_CREW |&gt;\n  filter(tconst == original_movie_tconst) |&gt;\n  separate_rows(directors, writers, sep = \",\") |&gt;\n  pivot_longer(c(directors, writers), names_to = \"role\", values_to = \"nconst\") |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, role, birthYear, deathYear)\n\n# Filter for crew members who are still alive\nalive_crew &lt;- original_crew |&gt;\n  filter(is.na(deathYear))\n\nalive_crew |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nThis result says that the these top directors and writers are still alive.\n\n\n6.4 Once you have found your classic movie to remake, confirm whether key actors, directors, or writers from the original are still alive. If so, you need to contact your legal department to ensure they can secure the rights to the project. You may also want to include the classic actors as “fan service.”\nTo proceed with the remake of “The Shawshank Redemption,” I have confirmed that several key figures from the original are still alive. Morgan Freeman and Tim Robbins, who played iconic roles, are both alive and could potentially be included in the project for “fan service.” Additionally, Frank Darabont, the original director, and Stephen King, the writer, are also still active.\nTo move forward, we will need to contact the legal department to secure the necessary rights from Castle Rock Entertainment for the film and Stephen King’s estate for the novella adaptation. Including classic actors like Freeman and Robbins in cameo roles would not only pay tribute to the original but also help attract loyal fans while building excitement for a new generation of viewers.\n\n\n\n\n\n\nTask 7: Elevator Pitch\n\n\n\n\n\n\n\n\nElevator Pitch: Remake of “The Shawshank Redemption”\nI’ve got a proposal that’s going to excite both loyal fans and a whole new audience — a modern remake of “The Shawshank Redemption.” This film has been a staple of cinema since 1994, ranked #1 on IMDb with a near-perfect rating of 9.3/10 and over 2.9 million votes. It’s clear: people love this story of hope, resilience, and friendship, and it’s time to bring it back with a fresh perspective.\nWe have an incredible opportunity to remake this classic with a stunning team. Woody Allen, known for his unique storytelling style, is our director. With 48 successful movies, Woody brings the creative depth needed to honor the original while offering a new artistic take.\nFor casting, we’re aiming high: Samuel L. Jackson as “Red.” With 72 hit films to his name, Jackson has the gravitas and warmth to bring this iconic character to life. And to make it even more dynamic, Robert De Niro, with 71 successful films, will play a key supporting role, ensuring this cast delivers both emotional depth and star power.\nWhy drama? In recent years, drama has consistently been the top-performing genre, producing the most successful films. From 2010 onward, it has led with over 3,290 successful titles, proving that audiences are hungry for emotionally-driven stories. With the powerhouse combination of Woody Allen, Samuel L. Jackson, and Robert De Niro, we’re confident that this remake will not only honor the original but also become a hit for modern viewers.\nTogether, this dream team is set to breathe new life into one of the greatest stories ever told, while maintaining the emotional core that made the original so beloved.\n\n\n\n\n\n\nKey Points for the movie:\n\n\n\n\n\n\nClassic Movie: The Shawshank Redemption is a highly rated film with over 2.9 million IMDb votes and a 9.3/10 rating, making it a prime candidate for a remake.\nStar Power: Samuel L. Jackson and Robert De Niro have over 140 successful films between them, bringing star power and acting prowess to the remake.\nDirector: Woody Allen, with 48 successful films, provides the artistic vision necessary to honor the original while offering a fresh perspective.\nMarket Potential: Drama continues to dominate as the top-performing genre, with over 3,290 successful titles released since 2010, making this remake a perfect fit for current audience preferences.\nNostalgia & Fan Service: Original actors like Morgan Freeman and Tim Robbins can make cameo appearances, blending nostalgia with a modern twist to attract loyal fans and new viewers alike."
  },
  {
    "objectID": "mp02.html#library-setup",
    "href": "mp02.html#library-setup",
    "title": "Mini Project 2",
    "section": "Library Setup",
    "text": "Library Setup\n\nInstall Required Packages\nWe will be analyzing various data from various sources. Following libraries are needed for this analysis. First check if the library is already installed and then install if not installed.\n\nif (!require(\"readr\")) install.packages(\"readr\") \nif (!require(\"dplyr\")) install.packages(\"dplyr\") \nif (!require(\"ggplot2\")) install.packages(\"ggplot2\")\nif (!require(\"stringr\")) install.packages(\"stringr\")\nif (!require(\"tidyr\")) install.packages(\"tidyr\")\n\n\n\nLoad the packages\nOnce the packages are installed, those will be loaded to the workspace so that they can be used later.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(tidyr)"
  },
  {
    "objectID": "mp02.html#load-data",
    "href": "mp02.html#load-data",
    "title": "Mini Project 2",
    "section": "Load Data",
    "text": "Load Data\nSince we have now setup libraries, we will now download the data to our project so that we can use later fo our analysis\n\nget_imdb_file &lt;- function(fname){\n    BASE_URL &lt;- \"https://datasets.imdbws.com/\"\n    fname_ext &lt;- paste0(fname, \".tsv.gz\")\n    if(!file.exists(fname_ext)){\n        FILE_URL &lt;- paste0(BASE_URL, fname_ext)\n        download.file(FILE_URL, \n                      destfile = fname_ext)\n    }\n    as.data.frame(readr::read_tsv(fname_ext, lazy=FALSE))\n}\n\nNAME_BASICS      &lt;- get_imdb_file(\"name.basics\")\n\n\nNAME_BASICS &lt;- get_imdb_file(\"name.basics\")\n\n\nTITLE_BASICS &lt;- get_imdb_file(\"title.basics\")\n\n\nTITLE_RATINGS &lt;- get_imdb_file(\"title.ratings\")\n\n\nTITLE_CREW &lt;- get_imdb_file(\"title.crew\")\n\n\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title.principals\")"
  },
  {
    "objectID": "oct17class.html",
    "href": "oct17class.html",
    "title": "oct17class",
    "section": "",
    "text": "library(ggplot2)\n\nScatter plot of price vs carat, faceted by cut\nggplot(diamonds, aes(x = carat, y = price)) + geom_point(alpha = 0.5) + # Add transparency to handle overplotting facet_wrap(~ cut) + # Facet by cut labs(title = “Price vs Carat, Faceted by Cut”, x = “Carat”, y = “Price”) + theme_minimal() ````"
  },
  {
    "objectID": "mp02.html#task-3",
    "href": "mp02.html#task-3",
    "title": "Mini Project 02",
    "section": "Task 3",
    "text": "Task 3\n\n# Add a custom success metric to TITLE_RATINGS\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log10(numVotes))\n\nglimpse(TITLE_RATINGS)\n\nRows: 373,996\nColumns: 4\n$ tconst         &lt;chr&gt; \"tt0000001\", \"tt0000002\", \"tt0000003\", \"tt0000004\", \"tt…\n$ averageRating  &lt;dbl&gt; 5.7, 5.6, 6.5, 5.4, 6.2, 5.0, 5.4, 5.4, 5.4, 6.8, 5.2, …\n$ numVotes       &lt;dbl&gt; 2095, 283, 2102, 183, 2837, 196, 889, 2242, 215, 7724, …\n$ success_metric &lt;dbl&gt; 18.930749, 13.730004, 21.597113, 12.217236, 21.407728, …\n\n\n\nmovies_only &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"movie\")\n\n# Add a custom success metric to the movies_ratings table\nmovies_ratings &lt;- TITLE_RATINGS |&gt;\n  inner_join(movies_only, by = \"tconst\")\n\n\n# View the top 10 movies by success_metric\nmovies_ratings |&gt;\n  arrange(desc(success_metric)) |&gt;\n  head(10) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric)\n\n                                        primaryTitle averageRating numVotes\n1                           The Shawshank Redemption           9.3  2951083\n2                                    The Dark Knight           9.0  2932304\n3                                      The Godfather           9.2  2057179\n4      The Lord of the Rings: The Return of the King           9.0  2020203\n5                                       Pulp Fiction           8.9  2266176\n6                                          Inception           8.8  2602440\n7  The Lord of the Rings: The Fellowship of the Ring           8.9  2049867\n8                                         Fight Club           8.8  2382865\n9                                       Forrest Gump           8.8  2308847\n10                                  Schindler's List           9.0  1480407\n   success_metric\n1        60.17083\n2        58.20488\n3        58.08210\n4        56.74856\n5        56.56211\n6        56.45535\n7        56.17436\n8        56.11848\n9        55.99788\n10       55.53343"
  },
  {
    "objectID": "mp02.html#low-scoring-popular-movies-validation",
    "href": "mp02.html#low-scoring-popular-movies-validation",
    "title": "Mini Project 02",
    "section": "Low-Scoring Popular Movies Validation",
    "text": "Low-Scoring Popular Movies Validation\n\n# Select 3-5 movies with a high number of votes but low success metric\nmovies_ratings |&gt;\n  filter(numVotes &gt; 100000) |&gt; # Filter for popular movies\n  arrange(success_metric) |&gt; # Sort by lowest success metric\n  head(5) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric)\n\n       primaryTitle averageRating numVotes success_metric\n1             Radhe           1.9   180234        9.98609\n2        Epic Movie           2.4   110309       12.10227\n3         Adipurush           2.7   134356       13.84629\n4 Meet the Spartans           2.8   112308       14.14115\n5          365 Days           3.3   100866       16.51236\n\n\n\n3. Prestige Actor or Director Validation\n\n# Example for a director like Steven Spielberg\n# TITLE_CREW |&gt;\n#    select(directors)\n\n# Filter for Steven Spielberg in the NAME_BASICS table\nspielberg_nconst &lt;- NAME_BASICS |&gt;\n  filter(primaryName == \"Steven Spielberg\") |&gt;\n  pull(nconst)\n\n# Filter TITLE_CREW for movies directed by Steven Spielberg\nspielberg_projects &lt;- TITLE_CREW |&gt;\n  filter(directors == spielberg_nconst) # Spielberg's nconst from the previous step\n\n# Join with TITLE_BASICS to get movie titles\nspielberg_movies &lt;- spielberg_projects |&gt;\n  inner_join(movies_ratings, by = \"tconst\") # Join with the ratings table to get success metric\n\n# Arrange by success metric to see top movies\nspielberg_movies |&gt;\n  arrange(desc(success_metric)) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n# spielberg_success &lt;- movies_ratings |&gt;\n#     filter(tconst %in% spielberg_tconst) |&gt;\n#     arrange(desc(success_metric))\n#\n# print(spielberg_success)"
  },
  {
    "objectID": "mp02.html#other-spot-check-validation",
    "href": "mp02.html#other-spot-check-validation",
    "title": "Mini Project 02",
    "section": "4. Other Spot-Check Validation",
    "text": "4. Other Spot-Check Validation\n\n# # Compare success scores across genres\n# genre_success &lt;- movies_ratings |&gt;\n#     group_by(genre) |&gt;\n#     summarise(avg_success = mean(success_metric, na.rm = TRUE)) |&gt;\n#     arrange(desc(avg_success))\n#\n# print(genre_success)\n\nlibrary(tidyr)\n\n# Split genres into multiple rows\nmovies_with_genres &lt;- movies_ratings |&gt;\n  separate_rows(genres, sep = \",\")\n\n# Calculate average success metric by genre\nmovies_with_genres |&gt;\n  group_by(genres) |&gt;\n  summarise(\n    avg_success = mean(success_metric, na.rm = TRUE),\n    num_movies = n()\n  ) |&gt; # Count how many movies are in each genre\n  arrange(desc(avg_success)) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n5. Numerical Threshold for Success\n\n# Determine quantiles for success_metric\nquantile(movies_ratings$success_metric, probs = seq(0, 1, by = 0.05))\n\n       0%        5%       10%       15%       20%       25%       30%       35% \n 2.068186  8.621344 10.187988 11.247041 12.058179 12.759427 13.407628 14.013592 \n      40%       45%       50%       55%       60%       65%       70%       75% \n14.601748 15.212304 15.853725 16.539468 17.308795 18.184748 19.151397 20.320207 \n      80%       85%       90%       95%      100% \n21.703213 23.447132 25.849774 29.816939 60.170827 \n\n\n\n\nFinding movies with success\n\n# Define a threshold for success based on the 90th percentile\nsuccess_threshold &lt;- 25.85\n\n# Filter movies that are considered \"successful\"\nmovies_ratings |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric) |&gt;\n  head(100) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n###Examining Success by Genre and Decade 1. Prepare Data for Analysis\n\n# Ensure that startYear is numeric\nmovies_ratings &lt;- movies_ratings |&gt;\n  mutate(startYear = as.numeric(startYear))\n\n# Separate the genres into individual rows (some movies have multiple genres)\nmovies_genre &lt;- movies_ratings |&gt;\n  separate_rows(genres, sep = \",\")\n\n# Rename the 'genres' column to 'genre'\nmovies_genre &lt;- movies_genre |&gt;\n  rename(genre = genres)\n\n\nWhat Was the Genre with the Most “Successes” in Each Decade?\n\n\n# Create a new column for the decade\nmovies_genre &lt;- movies_genre |&gt;\n  mutate(decade = floor(startYear / 10) * 10)\n\n# Filter for successful movies (using the threshold from earlier)\nsuccessful_movies_by_decade &lt;- movies_genre |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(decade, genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  arrange(decade, desc(num_successes))\n\n# Find the top genre in each decade\nsuccessful_movies_by_decade |&gt;\n  group_by(decade) |&gt;\n  slice_max(order_by = num_successes, n = 1) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\n3. What Genre Consistently Has the Most “Successes”?\n\n# Total number of successes per genre across all decades\ntotal_successes_by_genre &lt;- movies_genre |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(genre) |&gt;\n  summarise(total_successes = n(), .groups = \"drop\") |&gt;\n  arrange(desc(total_successes))\n\ntotal_successes_by_genre |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\n4. What Genre Used to Reliably Produce “Successes” but Has Fallen Out of Favor?\n\n# Successes in earlier decades (before 2000) vs recent decades (2000 and later)\nsuccess_by_era &lt;- movies_genre |&gt;\n  mutate(era = ifelse(decade &lt; 1980, \"Before 2000\", \"2000 and After\")) |&gt;\n  filter(success_metric &gt;= success_threshold) |&gt;\n  group_by(era, genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  pivot_wider(names_from = era, values_from = num_successes, values_fill = 0) |&gt;\n  mutate(fall_out = `Before 2000` &gt; 0 & `2000 and After` == 0) |&gt;\n  filter(fall_out == TRUE)\n\nsuccess_by_era |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\n5. What Genre Has Produced the Most “Successes” Since 2010?\n\n# Filter for movies since 2010 and count successes by genre\nmovies_genre |&gt;\n  filter(startYear &gt;= 2010, success_metric &gt;= success_threshold) |&gt;\n  group_by(genre) |&gt;\n  summarise(num_successes = n(), .groups = \"drop\") |&gt;\n  arrange(desc(num_successes)) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\n6. Does the Genre with the Most Successes Have the Highest Success Rate?\n\n# Calculate the total number of movies per genre and the number of successes\nmovies_genre |&gt;\n  group_by(genre) |&gt;\n  summarise(\n    total_movies = n(),\n    num_successes = sum(success_metric &gt;= success_threshold),\n    success_rate = num_successes / total_movies * 100,\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(success_rate)) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\n7. What Genre Has Become More Popular in Recent Years?\n\n# Compare genre popularity by counting the number of movies in recent years (post-2010) vs earlier\n# Ensure there are no missing startYear values and proceed with the calculation\nmovies_genre |&gt;\n  filter(!is.na(startYear)) |&gt; # Filter out rows with NA in startYear\n  mutate(era = ifelse(startYear &gt;= 2010, \"Post 2010\", \"Pre 2010\")) |&gt;\n  group_by(era, genre) |&gt;\n  summarise(num_movies = n(), .groups = \"drop\") |&gt;\n  pivot_wider(names_from = era, values_from = num_movies, values_fill = 0) |&gt;\n  mutate(popularity_increase = `Post 2010` &gt; `Pre 2010`) |&gt;\n  filter(popularity_increase == TRUE) |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\n\n\nTask 5: Key Personnel\nIdentify (at least) two actors and one director who you will target as the key talent for your movie. Write a short “pitch” as to why they are likely to be successful. You should support your pitch with at least one graphic and one table.\n\n# Join TITLE_PRINCIPALS with movies_ratings to get actors with successful movies\nsuccessful_actors &lt;- TITLE_PRINCIPALS |&gt;\n  inner_join(movies_ratings, by = \"tconst\") |&gt;\n  filter(category == \"actor\" | category == \"actress\") |&gt;\n  group_by(nconst) |&gt;\n  summarise(\n    num_successful_movies = sum(success_metric &gt;= success_threshold),\n    avg_success_metric = mean(success_metric, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(num_successful_movies)) |&gt;\n  head(10)\n\n# Join with NAME_BASICS to get actor names\nsuccessful_actors &lt;- successful_actors |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, num_successful_movies, avg_success_metric)\n\nsuccessful_actors |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nDirectors: Now let’s find the most successful director:\n\n# Join TITLE_CREW with movies_ratings to get directors with successful movies\nsuccessful_directors &lt;- TITLE_CREW |&gt;\n  inner_join(movies_ratings, by = \"tconst\") |&gt;\n  filter(!is.na(directors)) |&gt;\n  separate_rows(directors, sep = \",\") |&gt;\n  group_by(directors) |&gt;\n  summarise(\n    num_successful_movies = sum(success_metric &gt;= success_threshold),\n    avg_success_metric = mean(success_metric, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(num_successful_movies)) |&gt;\n  head(5)\n\n# Join with NAME_BASICS to get director names\nsuccessful_directors &lt;- successful_directors |&gt;\n  inner_join(NAME_BASICS, by = c(\"directors\" = \"nconst\")) |&gt;\n  select(primaryName, num_successful_movies, avg_success_metric)\n\nsuccessful_directors |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nStep 2: Generate a Graphic for Actor/Director Success\n\nlibrary(ggplot2)\n\n# Combine actors and directors for visualization\nkey_talent &lt;- rbind(\n  successful_actors |&gt; head(2),\n  successful_directors |&gt; head(1)\n)\n\n# Create a bar plot for key talent success\nggplot(key_talent, aes(x = reorder(primaryName, -num_successful_movies), y = num_successful_movies)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(\n    title = \"Number of Successful Movies for Key Talent\",\n    x = \"Talent\",\n    y = \"Number of Successful Movies\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nStep 3: Create a Table for Actor/Director Success\n\nif (!require(\"kableExtra\")) install.packages(\"kableExtra\")\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Add role information for actors and directors\nactors &lt;- successful_actors |&gt;\n  head(2) |&gt;\n  mutate(role = \"Actor\")\ndirectors &lt;- successful_directors |&gt;\n  head(1) |&gt;\n  mutate(role = \"Director\")\n\n# Combine actors and directors into one table\nkey_talent &lt;- rbind(actors, directors)\n\n\n# Create a table showing the role, number of successful movies, and average success metric\nkey_talent |&gt;\n  select(primaryName, role, num_successful_movies, avg_success_metric) |&gt;\n  kable(col.names = c(\"Name\", \"Role\", \"Successful Movies\", \"Average Success Metric\")) |&gt;\n  kable_styling(bootstrap_options = \"striped\", full_width = F)\n\n\n\n\nName\nRole\nSuccessful Movies\nAverage Success Metric\n\n\n\n\nSamuel L. Jackson\nActor\n72\n30.51962\n\n\nRobert De Niro\nActor\n71\n31.50986\n\n\nWoody Allen\nDirector\n48\n32.34295\n\n\n\n\n\n\n\n\n\nTask 6: Finding a Classic Movie to Remake\nFind a classic movie to remake with your key talent. The original should have a large number of IMDb ratings, a high average rating, and not have been remade in the past 25 years.4\nOnce you have found your classic movie to remake, confirm whether key actors, directors, or writers from the original are still alive. If so, you need to contact your legal department to ensure they can secure the rights to the project. You may also want to include the classic actors as “fan service.”\nStep 1: Filter for Classic Movies\n\n# Define the year cutoff for remakes (25 years ago)\nyear_cutoff &lt;- 1999\n\n# Filter for classic movies that haven't been remade in the last 25 years\nclassic_movies &lt;- movies_ratings |&gt;\n  filter(\n    startYear &lt; year_cutoff,\n    averageRating &gt;= 7.5,\n    numVotes &gt;= 50000\n  ) |&gt;\n  arrange(desc(averageRating))\n\nclassic_movies |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nStep 2: Check if Original Actors Are Still Alive\n\n# Get key actors from the original movie\noriginal_movie_tconst &lt;- classic_movies$tconst[1] # Example: select the first movie in the list\n\n# Find actors in the original movie\noriginal_actors &lt;- TITLE_PRINCIPALS |&gt;\n  filter(tconst == original_movie_tconst, category %in% c(\"actor\", \"actress\")) |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, birthYear, deathYear)\n\n# Filter for actors who are still alive\nalive_actors &lt;- original_actors |&gt;\n  filter(is.na(deathYear))\n\nprint(alive_actors)\n\n        primaryName birthYear deathYear\n1       Tim Robbins      1958        NA\n2    Morgan Freeman      1937        NA\n3        Bob Gunton      1945        NA\n4    William Sadler      1950        NA\n5      Clancy Brown      1959        NA\n6       Gil Bellows      1967        NA\n7      Mark Rolston      1956        NA\n8    Jeffrey DeMunn      1947        NA\n9 Larry Brandenburg      1948        NA\n\n\nStep 2: Check if Original Directors/writers Are Still Alive\n\n# Find directors and writers from the original movie\noriginal_crew &lt;- TITLE_CREW |&gt;\n  filter(tconst == original_movie_tconst) |&gt;\n  separate_rows(directors, writers, sep = \",\") |&gt;\n  pivot_longer(c(directors, writers), names_to = \"role\", values_to = \"nconst\") |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  select(primaryName, role, birthYear, deathYear)\n\n# Filter for crew members who are still alive\nalive_crew &lt;- original_crew |&gt;\n  filter(is.na(deathYear))\n\nalive_crew |&gt;\n  DT::datatable(options = list(pageLength = 5))\n\n\n\n\n\nStep 4: Consider Including Original Talent and Legal Clearance"
  }
]